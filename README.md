
# TAIC Smart Assistant

> An intelligent assistant and knowledge search tool for the New Zealand Transport Accident Investigation Commission

[![License: CC BY 4.0](https://img.shields.io/badge/License-CC%20BY%204.0-lightgrey.svg)](https://creativecommons.org/licenses/by/4.0/)
[![Built with Gradio](https://img.shields.io/badge/Built%20with-Gradio-orange)](https://gradio.app/)

---

## Preview

![TAIC Smart Assistant Demo](https://github.com/1jamesthompson1/TAIC_smart_assistant/releases/download/v0.4.0/demo.gif)

---

## Features

ü§ñ **AI-Powered Assistant**
- Interactive chat interface with conversational AI
- Context-aware responses using TAIC's knowledge base
- Conversation history and management

üîç **Advanced Knowledge Search**
- Vector-based semantic search across TAIC, ATSB and TSB documents
- Filter by document type, agency, year, and transport mode
- Visual analytics and result export capabilities

---

## Project Status

This chat interface has proven to be significantly more user-friendly than other methods. This means that as many tools will be built behind the chat interface.

As of October 2025 this app is going into organisation wide deployment. There is no public access at the moment.

The app implementation is completely seperate from the code base, new deployments can be spun up with relative ease. However it is access to the database generated by [taic-engine](https://github.com/1jamesthompson1/TAIC-report-summary).

## Contributing

### Setup for Local Development

_Note that this has only ever been 'completed' on Linux machines. For ease of use I would recommend [WSL](https://learn.microsoft.com/en-us/windows/wsl/about) for windows users_

1. **Install dependencies**

```bash
# Install uv if you haven't already
curl -Ls https://astral.sh/uv/install.sh | sh

# Install project dependencies
uv sync --dev

# Setup pre-commits
uv run pre-commit install
```

2. **Get the vector database**
*This is simply so that when you want to test the webapp you can use the searcher quickly as it is locally fetching data.*

Install `azcopy` by following: https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azcopy-v10?tabs=apt
Install `az cli` by following: https://learn.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest

You will then need to login with `az login`.

```bash
# Download and setup the vector database
uv run python working_files/download_vector_db.py
```

3. **Environment configuration**

```bash
# Copy and configure your environment variables
cp .env.example .env
# Edit .env with your Azure credentials and API keys
```

4. **Run the app locally**

```bash
uv run uvicorn app:app --host 0.0.0.0 --port 8080 --reload
```

5. **Access the application**
- Open your browser to `http://localhost:8080`
- For the tools interface: `http://localhost:8080/tools`

### Development Workflow

1. Create a feature branch from `main`
2. Make your changes with appropriate commit messages
3. Create a pull request
4. When merging, use squash-and-merge with conventional commit keywords in the final commit message for automatic version bumping

#### Version Management

This project uses semantic versioning (MAJOR.MINOR.PATCH):

- **Patch** versions are auto-bumped on every push to main
- **Minor/Major** versions can be manually triggered using GitHub Actions
- All conversations and searches store the app version they were created with
- Version compatibility checking prevents loading incompatible data

##### Auto-versioning Rules

Commit messages can trigger different version bumps:

- `BREAKING:` or `breaking change:` ‚Üí Major version bump
- `feat:` or `feature:` or `minor:` ‚Üí Minor version bump  
- Everything else ‚Üí Patch version bump

##### Manual Version Bumping

Use GitHub Actions workflow "Auto Version Bump" with manual trigger to specify version bump type.

##### Manual Version Bumping

Use GitHub Actions workflow "Auto Version Bump" with manual trigger to specify version bump type.

**Note for Pull Requests**: When using squash-and-merge, ensure your final squashed commit message contains the appropriate keywords above, as the GitHub Action analyzes the squashed commit message for version bumping.

### CI/CD Configuration

This project uses GitHub Actions for automated testing and deployment. The following secrets need to be configured in your GitHub repository:

#### Required GitHub Secrets

| Secret Name | Description |
|-------------|-------------|
| `AZURE_CLIENT_ID` | Azure AD application client ID for authentication |
| `AZURE_CLIENT_SECRET` | Azure AD application client secret |
| `AZURE_TENANT_ID` | Azure AD tenant ID |
| `AZURE_SUBSCRIPTION_ID` | Azure subscription ID for blob storage access |
| `AZURE_STORAGE_ACCOUNT_NAME` | Azure Storage account name where test config is stored |

#### Test Environment Setup

The CI pipeline automatically downloads a test configuration file (`test.env`) from Azure Blob Storage during test runs. This file should contain all necessary environment variables for testing with real services.

To set up the test environment:

1. Create a `test.env` file with your test environment variables
2. Upload it to Azure Blob Storage in a `configs` container
3. Ensure the service principal has read access to the blob

The test workflow will:
- Authenticate with Azure using the service principal
- Download the test configuration
- Run tests with both mocked and real services
